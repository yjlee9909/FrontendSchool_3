<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
        // 객체, {} - 리터럴 - 변수에 할당되기 전의 값 {}-객체의 리터럴 [] - 배열의 리터럴 "" - 문자의 리터럴 123- 숫자의 리터럴...
        // 객체 자료형은 키와 벨류로 이루어짐
        let myObj = {
            // key: value 한 쌍을 합쳐서 프로퍼티라고 부름
            val1 : 10,
            val2 : 30
        }; 
        // .length 프로퍼티 네임으로 배열의 길이를 알 수 있다.
        // Array(2) ; 길이가 2인 배열
        // Array(2,3) ; [2,3]
        // 배열 안 배열 [[],[]]
        // 1. 배열 생성할때 리터럴로 선언 (일반적 방법)
        // let myarry = [];
        // 2. 배열의 생성자 함수
        // let myArray = new Array(5); //길이 5개인 배열 생성
        // let myArray2 = new Array(2,3,4); // [2,3,4] 2개 이상 넣는 순간 여러개 숫자를 원소로 한다.
        // 배열 안 값에 접근
        // myArray2[0]; 인덱스 번호를 통한 접근 (문자열 역시 인덱스 방식으로 접근 가능)
        // myArray2[0] = 100; 할당 가능하지만
        // let val = 'hello';
        // val[2] = 'z';
        // 배열은 값 수정이 가능하지만 문자열은 값은 바꿀 수 없다.
        // -> 문자열의 불변성

        // 생성과 동시에 값에 접근이 가능하다.
        // [1,2,3,4,5][2] 
        // 원시타입은 값을 바꿀수 없습니다.  접근 주소를 갈아치우는거에요!
        // 기본형 데이터, 참조형 데이터에 대해서 찾아보시면 됩니다
        // 기본형 데이터: 숫자, 문자열, 불리언, null, undefined, symbol
        // 나머지는 참조형 데이터입니다.
        // 기본형 데이터는 값을 바꿀 수 없습니다.
        
        // push 맨 뒤에 추가 unshift 맨 앞에 추가
        // unshift 는 기본적으로 배열의 length 반환한다
        const cafe = ['coffee', 'cake', 'tea', 'cookie'];
        const count = cafe.unshift('bread');

        //count
        // expected output: 5 갯수를 반환한다 
        //cafe
        // expected output: ['bread', 'coffee', 'cake', 'tea', 'cookie']

        // pop 맨 뒤 요소 지우기 , shift 맨 앞 요소 지우기

        // splice 요소 추가하기, 기존 요소 삭제하기, 기존 요소 대체하기
        // slice, splice 헷갈림!!!
        // .splice(추가할 위치, 삭제할 갯수, 대체할 요소);
        // .splice(추가할 위치, 삭제할 갯수);
        // -1 인 경우 뒤에서부터 0, -1 에 해당

        // slice(잘라낼 시작점의 인덱스, 종료 지점인덱스-1까지)
        // 인자 1개인 경우 시작점부터 끝까지 다 잘라냄
        // 원래 배열을 건들지 않는다.

        // 돌고래, 코끼리 slice하기
        // fish.slice(2,3);
        // fish.slice(-1);

        // indexOf()
        // indexOf(sdf, 1) ; 해당 숫자 인덱스부터 검색
        // 찾으려는 조건이 존재하지 않는다면 -1을 반환

        const cafe2= ['tea','coffee', 'cookie', 'tea', 'cake'];
        console.log(cafe2.indexOf('tea'));
        // 왼쪽부터 가장 처음 만나는 인덱스 번호를 반환

        // isArray
        // join
        // 반환값이 존재하지 않는 경우에는 메소드 체이닝이 불가능
        // cafe2.join('/').split('/');

        // 체이닝 : 메소드 연달아서 사용 가능
        // 문자열의 메소드 .split(), .
        // 문자열에서 사용할 수 있는 함수 -> 문자열의 메소드

        // includes 
        // includes('sdfs', n); -> n자리에 존재하는지

        // find
        // i => i>5;
        // i를 하나씩 넣어보면서 i>5라는 조건에 맞는 1개의 값을 반환

        // filter은 끝까지 다 찾아봄 2-3-16 
        // 배열 [] 안에 원소가 {} 객체임

        // map
        // 원하는 값을 뽑아내서 새로운 배열로 만들어냄 (데이터 가공도 가능)
        // filter는 걸러내는 것 조건을 제시해서 
        // filter는 조건 메소드가 자체적으로 있고 map은 따로 없다(함수자리에 조건문을 걸면 메소드처럼 쓸 수 있다) 처럼 이해하면 될까요?
        const arr = [{
        'name' : 'title1',
        'contents' : 'contents1',
        'dataNum' : 1,
        'data' : [1, 2, 3]
        }, {
        'name' : 'title2',
        'contents' : 'contents2',
        'dataNum' : 2,
        'data' : [1, 2, 3]
        }, {
        'name' : 'title3',
        'contents' : 'contents3',
        'dataNum' : 3,
        'data' : [1, 2, 100]
        }, {
        'name' : 'title4',
        'contents' : 'contents4',
        'dataNum' : 4,
        'data' : [1, 2, 3]
        }, {
        'name' : 'title5',
        'contents' : 'contents5',
        'dataNum' : 5,
        'data' : [1, 2, 100]
        }];


        //arr.map(i => i.name);
        // i에 배열의 원소가 하나씩 하나씩 들어감
        const newArr = arr.map(function (i) {
            return i.name;
        });
        //expected output: ['title1', 'title2', 'title3', 'title4', 'title5']

        // arr.map(i => i.name).indexOf('title3');
        //expected output: 2

        var studentList = [
            {
                id: 1, name: '원범', score: 'great'
            },
            {
                id: 2, name: '김진', score: 'nice'
            },
            {
                id: 3, name: '혜원', score: 'good'
            },
            {
                id: 4, name: '재현', score: 'too cool for school'
            }
        ]
        // map메소드를 이용해서 name의 값들을 원소로 하는 새로운 배열을 만들어 봅시다!
        const newArr1 = studentList.map (function (i) {
            return i.name;
        });

        // forEach()
        const arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        // forEach - 결과값 반환 (옛날)
        // map - 결과값 모아서 배열로 반환
        // function(i) {return console.log(i)};
        arr1.forEach(i => console.log(i));
        // expected output: 1
        // expected output: 2
        // expected output: 3
        // expected output: 4
        // expected output: 5
        // expected output: 6
        // expected output: 7
        // expected output: 8
        // expected output: 9
        // expected output: 10

        // concat 결합 새로운 배열 만들 수 있다. 기존 배열 변경하지 않음

        // sort()
        const arr3 = [3, 4, 1, 2]
        arr3.sort();
        //expected output: [1, 2, 3, 4]

        const vegetable = ['beet', 'carrot', 'apple']
        vegetable.sort();
        //expected output: ['apple', 'beet', 'carrot']
        
        // 숫자는 문자열과 다르게 정렬된다 문자열은 abcde순으로
        // sort -> 배열 안의 원소를 기본적으로 문자로 취급함
        // 유니코드 상의 순서로 배치 100000, 200, 40 순

        // 그래서 숫자 정렬 방법
        const arrNum = [13, 9, 10, 2];
        //arrNum.sort(); // 10, 13, 2, 9 (1, 1, 2, 9)
        arrNum.sort(function(a, b){

            // console.log("a : " + a);
            // console.log("b : " + b);
            // console.log(`a: ${a}, b: ${b}`);

            return a - b;
        });
        // a, b
        // 버블소팅인지는 확실하지 않다.
        // 9 - 13 -> 음수인 경우 두 위치를 바꿔줌 ==> (9,13,10,2)
        //  10 - 9 -> 양수 -> 자리 변경 x ==> 9,13,10,2
        // 10 - 13 -> 음수 -> 9, 10, 13, 2
        // 10 - 9 -> 그대로
        // 2 - 10 -> 음수 -> 9 ,2, 10, 13
        // 2 - 9 -> 음수 -> 2 9 10 13
        // compare 함수를 sort의 인자로 넣어줘야 숫자 정렬이 된다.

        // 
    </script>
</body>
</html>